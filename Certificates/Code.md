# Code Signing
[Wikipedia](https://en.wikipedia.org/wiki/Code_signing)

Code signing, program signing

## Windows PE
- Timestamp is optional (and not reliable)
- A PE program can have multiple signatures
- [PKCS #7](README.md#pkcs-7)

[Authenticode (I): Understanding Windows Authenticode -- RME-DisCo Research Group](https://reversea.me/index.php/authenticode-i-understanding-windows-authenticode/)

Signing:
- [SignTool - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool)
  - Windows only
    - Scoop: [TheRandomLabs/Scoop-Bucket/bucket/windows-sdk-signing-tools.json](https://github.com/TheRandomLabs/Scoop-Bucket/blob/master/bucket/windows-sdk-signing-tools.json)
  - 0.5 MiB
  - Rust
    - [rust-codesign: Microsoft code signing library (and utility) for Rust](https://github.com/forbjok/rust-codesign)
    - [SecSamDev/signtool-rs: A library to simplify the usage of Microsoft code signing library (SignTool) for Rust](https://github.com/SecSamDev/signtool-rs)
    - [tugger-windows-codesign - crates.io: Rust Package Registry](https://crates.io/crates/tugger-windows-codesign)

  [Using SignTool to Sign a File - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/seccrypto/using-signtool-to-sign-a-file)

  Seperate signing:
  - `/dg`: Generates the digest to be signed and the unsigned PKCS7 files. The output digest and PKCS7 files are `<Path>\<FileName>.dig` and `<Path>\<FileName>.p7u`. To output an extra XML file, use `/dxml`.

    Still needs to specify a cert to generate the PKCS7 file.
  - `/ds`: Signs the digest only. The input file should be the digest generated by the `/dg` option. The output file is: `<File>.signed`.
  - `/di`: Creates the signature by ingesting the signed digest to the unsigned PKCS7 file. The input signed digest and unsigned PKCS7 files should be `<Path>\<FileName>.dig.signed` and `<Path>\<FileName>.p7u`.
  - `/dlib`: Specifies the DLL that implements the [`AuthenticodeDigestSign`](https://learn.microsoft.com/en-us/windows/win32/seccrypto/pfn-authenticode-digest-sign) function to sign the digest with. This option is equivalent to using SignTool separately with the `/dg`, `/ds`, and `/di` options. This option invokes all three as one atomic operation.

    [novotnyllc/KeyVaultSignToolWrapper: An extension around SignTool to call into Azure Key Vault for the signing](https://github.com/novotnyllc/KeyVaultSignToolWrapper)

    [AzureKeyVaultSignTool/src/lib.rs](https://github.com/vcsjones/AzureKeyVaultSignTool/blob/master/src/lib.rs)

  [digital signature - Signtool.exe /dg /ds /di options and timestamping - Stack Overflow](https://stackoverflow.com/questions/57930959/signtool-exe-dg-ds-di-options-and-timestamping)
  > The timestamping is an operation applied directly to the file itself, so the file must exist locally. Your remote signing service only works because only the digest needs to be signed, not the full binary.

  [Code signing how-to @ Matthew-Jones.com](https://www.matthew-jones.com/articles/codesigning.html)

- [osslsigncode: OpenSSL based Authenticode signing for PE/MSI/Java CAB files](https://github.com/mtrojnar/osslsigncode)
  - `scoop install osslsigncode`
- [rhboot/pesign: Linux tools for signed PE-COFF binaries](https://github.com/rhboot/pesign)
- [ebourg/jsign: Java implementation of Microsoft Authenticode for signing Windows executables, installers & scripts](https://github.com/ebourg/jsign)
  - [How to sign a digest generated by signtool /dg - ebourg/jsign - Discussion #199](https://github.com/ebourg/jsign/discussions/199)

- Azure
  - Azure Key Vault
    - [vcsjones/AzureSignTool: SignTool Library and Azure Key Vault Support](https://github.com/vcsjones/AzureSignTool)

      [Azure SignTool](https://vcsjones.dev/azure-signtool/)
    
    [sebastiean/volt: An open source Azure Key Vault API compatible server (emulator).](https://github.com/sebastiean/volt)
  - [Trusted Signing](https://learn.microsoft.com/en-us/azure/trusted-signing/quickstart?tabs=registerrp-portal,account-portal,certificateprofile-portal,deleteresources-portal)
    - [Levminer/trusted-signing-cli](https://github.com/levminer/trusted-signing-cli)

Verifying:
- [Sigcheck - Sysinternals | Microsoft Learn](https://learn.microsoft.com/en-us/sysinternals/downloads/sigcheck)
  - Windows only
- Rust
  - [pe-sign: A cross-platform rust no-std library for verifying and extracting signature information from PE files.](https://github.com/0xlane/pe-sign)
  - [google/authenticode-rs: Rust tools for working with Authenticode](https://github.com/google/authenticode-rs)
    - Digest only
  - [pelite::security - Rust](https://docs.rs/pelite/latest/pelite/security/index.html)

Others:
- [med0x2e/SigFlip: SigFlip is a tool for patching authenticode signed PE files (exe, dll, sys ..etc) without invalidating or breaking the existing signature.](https://github.com/med0x2e/SigFlip)

## ELF
- Linux: No official support
- Solaris

Tools:
- [signelf](https://github.com/hermannch/signelf)

  [signelf -- Digitally signing ELF binaries - CodeNoise](https://blog.codenoise.com/signelf-digitally-signing-elf-binaries)
- [NUAA-WatchDog/linux-elf-binary-signer: ✒️ Adding digital signature into ELF binary files.](https://github.com/NUAA-WatchDog/linux-elf-binary-signer)

### Linux
[security - Signed executables under Linux - Stack Overflow](https://stackoverflow.com/questions/1732927/signed-executables-under-linux)
> I wrote signed executable support for the Linux kernel (around version 2.4.3) a while back, and had the entire toolchain in place for signing executables, checking the signatures at `execve(2)` time, caching the signature validation information (clearing the validation when the file was opened for writing or otherwise modified), embedding the signatures into arbitrary ELF programs, etc. It did introduce some performance penalties upon the first execution of every program (because the kernel had to load in the *entire* file, rather than just demand-page the needed pages) but once the system was in a steady-state, it worked well.
> 
> But we decided to stop pursuing it because it faced several problems that were too large to justify the complexity:
> 
> - We had not yet built support for *signed libraries*. Signed libraries would require also modifying the `ld.so` loader and the `dlopen(3)` mechanism. This wasn't impossible but did complicate the interface: should we have the loader ask the kernel to validate a signature or should the computation be done entirely in userspace? How would one protect against a `strace(2)`d process if this portion of the validation is done in userspace? Would we be forced to forbid `strace(2)` entirely on such a system?
> 
>   What would we do about [programs that supply their own loader](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/)?
> 
> - A great many programs are written in languages that do not compile to ELF objects. We would need to provide *language-specific* modifications to `bash`, `perl`, `python`, `java`, `awk`, `sed`, and so on, for each of the interpreters to be able to *also* validate signatures. Since most of these programs are free-format plain text they lack the structure that made embedding digital signatures into ELF object files so easy. Where would the signatures be stored? In the scripts? In extended attributes? In an external database of signatures?
> 
> - Many interpreters are *wide open* about what they allow; `bash(1)` can communicate with remote systems *entirely on its own* using `echo` and `/dev/tcp`, and can easily be tricked into executing anything an attacker needs doing. Signed or not, you couldn't trust them once they were under control of a hacker.
> 
> - The prime motivator for signed executables support comes from rootkits replacing the system-provided `/bin/ps`, `/bin/ps`, `/bin/kill`, and so on. Yes, there are other useful reasons to have signed executables. However, rootkits got significantly more impressive over time, with many relying on *kernel* hacks to hide their activities from administrators. Once the kernel has been hacked, the whole game is over. As a result of the sophistication of rootkits the tools we were hoping to prevent from being used were falling out of favor in the hacking community.
> 
> - The kernel's module loading interface was wide-open. Once a process has `root` privilege, it was easy to inject a kernel module without any checking. We could have also written another verifier for kernel modules but the kernel's infrastructure around modules was very primitive.

## Apple
- [apple-codesign - crates.io: Rust Package Registry](https://crates.io/crates/apple-codesign)
  
  [Gregory Szorc's Digital Home | Pure Rust Implementation of Apple Code Signing](https://gregoryszorc.com/blog/2021/04/14/pure-rust-implementation-of-apple-code-signing/)

## Java
